// Copyright 2020 Thomas.Hoehenleitner [at] seerose.net
// Use of this source code is governed by a license that can be found in the LICENSE file.

// Package randomdummy generates random trice data for testing.
package randomdummy

import (
	"errors"
	"io"
	"math/rand"
	"os"
	"time"
)

const (
	// NoDelay avoids any internal waiting.
	NoDelay = time.Duration(0)

	// DefaultDelay performs a short internal waiting for output synchronisation
	DefaultDelay = time.Duration(2 * time.Millisecond)

	// NoLimit is used for limit and means endless (circular) data.
	NoLimit = 0

	// ZeroRandomSeed makes sure generated random numbers are the same from start to start.
	ZeroRandomSeed = 0

	// ChaosMode delivers bytes without structural relations.
	//ChaosMode = 0

	// BareModeNoSync delivers only 4 byte groups.
	//BareModeNoSync = 1

	// WrapModeWithValidCrc delivers only 8 byte wrap sequences with valid coltrol data but chaotic payload.
	//WrapModeWithValidCrc = 2
)

// Randomizer delivers an endless circle of random bytes
type Randomizer struct {
	mode  string        // structure mode in the Read data
	time  time.Duration // artificial Read delay
	limit int           // max number of bytes, 0 means no limit
	count int           // delivered bytes
}

// New creates an instance of Random.
//
// seed is used for random init. Use fixed value like 0 for identical start values.
// mode is used for bringing some structure in the Read data especiually for tests.
// time is used for an artificial Read delay
// limit is the max number of generated bytes, 0 means endless data
func New(seed int64, mode string, time time.Duration, limit int) *Randomizer {
	//rand.Seed(time.Now().UnixNano())
	rand.Seed(seed)
	r := &Randomizer{}
	r.mode = mode
	r.time = time
	r.limit = limit
	return r
}

func (p *Randomizer) fillBuffer(b []byte) (int, error) {
	var i int
	for i = range b {
		if 0 == p.limit || p.count+i < p.limit {
			b[i] = byte(rand.Intn(255))
		} else {
			os.Exit(0) // normally not returning
			// for testing returning takes part, "i, io.EOF" here for smoother testing
			p.count += i
			return i, io.EOF
		}
	}
	i++
	p.count += i
	return i, nil
}

// Read is the exported method.
func (p *Randomizer) Read(b []byte) (int, error) {
	var i int
	time.Sleep(p.time)
	switch p.mode {
	case "ChaosMode":
		fallthrough
	default:
		return p.fillBuffer(b)
	case "BareModeNoSync":
		if len(b) < 4 {
			return 0, errors.New("too short for bare")
		}
		b = b[:4] // limit len(b)
		for i = range b {
			if p.count+i >= p.limit {
				os.Exit(0) // normally not returning
				// for testing returning takes part, "i, io.EOF" here for smoother testing
				p.count += i
				return i, io.EOF
			}
			b[i] = byte(rand.Intn(255))
		}
	case "WrapModeWithValidCrc":
		if len(b) < 8 {
			return 0, errors.New("too short for wrap")
		}

		b = b[:8] // limit len(b)
		for i = range b {
			if p.count+i >= p.limit {
				os.Exit(0) // normally not returning
				// for testing returning takes part, "i, io.EOF" here for smoother testing
				p.count += i
				return i, io.EOF
			}
			b[i] = byte(rand.Intn(255))
		}
		b[0] = 235                                            // valid start byte
		b[1] = 96                                             // valid addr
		b[2] = 96                                             // valid addr
		b[3] = b[0] ^ b[1] ^ b[2] ^ b[4] ^ b[5] ^ b[6] ^ b[7] // compute crc
	}
	i++
	p.count += i
	return i, nil
}
