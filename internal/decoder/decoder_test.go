// Copyright 2020 Thomas.Hoehenleitner [at] seerose.net
// Use of this source code is governed by a license that can be found in the LICENSE file.

package decoder

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"strings"
	"testing"

	"github.com/rokath/trice/internal/emitter"
	"github.com/rokath/trice/internal/id"
	"github.com/rokath/trice/pkg/tst"
)

// testTable ist a slice of structs generated by the trice tool -testTable option.
type testTable []struct {
	in  []byte // byte buffer sequence
	exp string // output
}

//// unmarshalTriceIDListToSlice extracts the trice ID list byte slice to an items slice.
//// til is a result of a read til.json file or is a converted test string.
//// til can change during runtime, when an "trice update" occurs.
//// Just in case til is not consistent the err value is not nil.
//func unmarshalTriceIDListToSlice(tilJSON []byte) (list []id.Item, err error) {
//	if 0 < len(tilJSON) {
//		err = json.Unmarshal(tilJSON, &list)
//	}
//	return
//}

//  // newIDLut assumes til as JSON formatted input and returns a map for trice ID to fmt string translation.
//  func newIDLut(til []byte) (IDLookUp, error) {
//  	list, err := unmarshalTriceIDListToSlice(til)
//  	if nil != err {
//  		return nil, err
//  	}
//  	lut := id.MakeLut(list) // create look-up map
//  	return lut, nil
//  }

// doTableTest is the universal decoder test sequence.
func doTableTest(t *testing.T, f newDecoder, endianness bool, teTa testTable, inputDataType string) {
	lut := make(id.TriceIDLookUp)
	tst.AssertNoErr(t, lut.FromJSON([]byte(til)))
	buf := make([]byte, defaultSize)
	dec := f(lut, nil, endianness) // p is a new decoder instance
	for _, x := range teTa {
		in := ioutil.NopCloser(bytes.NewBuffer(x.in))
		if "unwrapped" == inputDataType {
			dec.setInput(in)
		} else if "wrapped" == inputDataType {
			dec.setInput(NewBareReaderFromWrap(in))
		} else {
			t.Fail()
		}
		var err error
		var n int
		var act string
		for nil == err {
			n, err = dec.Read(buf)
			if io.EOF == err && 0 == n {
				break
			}
			a := fmt.Sprint(string(buf[:n]))
			if emitter.SyncPacketPattern != a {
				act += a // ignore sync packets
			}
		}
		a := strings.TrimSuffix(act, "\\n")
		ab := strings.TrimSuffix(a, "\n")
		tst.EqualStrings(t, x.exp, ab)
	}
}

var (
	// til is the trace id list content for tests
	til = `{
	"33": {
		"Type": "t33",
		"Strg": "s33"
	},
	"12": {
		"Type": "t12",
		"Strg": "s12"
	}
}`
)
