// Copyright 2020 Thomas.Hoehenleitner [at] seerose.net
// Use of this source code is governed by a license that can be found in the LICENSE file.

package decoder

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"sync"
	"testing"

	"github.com/rokath/trice/internal/id"
	"github.com/tj/assert"
)

// testTable ist a struct slice generated by the trice tool -testTable option.
type testTable []struct {
	in  []byte // byte buffer sequence
	exp string // output
}

// doTableTest is the universal decoder test sequence.
func doCOBSTableTest(t *testing.T, out io.Writer, f newDecoder, endianness bool, teTa testTable) {
	var (
		// til is the trace id list content for test
		idl = `{
			"48324": {
				"Type": "TRICE16",
				"Strg": "MSG: START select = %d, TriceDepthMax =%4u\\n"
			},
			"53709": {
				"Type": "TRICE16",
				"Strg": "MSG: STOP  select = %d, TriceDepthMax =%4u\\n"
			}
		}
	`
	)
	lu := make(id.TriceIDLookUp) // empty
	luM := new(sync.RWMutex)
	assert.Nil(t, lu.FromJSON([]byte(idl)))
	lu.AddFmtCount(os.Stdout)
	buf := make([]byte, defaultSize)
	dec := f(out, lu, luM, nil, endianness) // a new decoder instance
	for _, x := range teTa {
		in := ioutil.NopCloser(bytes.NewBuffer(x.in))
		dec.setInput(in)
		lineStart := true
		var err error
		var n int
		var act string
		for nil == err {
			n, err = dec.Read(buf)
			if n == 0 {
				break
			}
			if ShowID != "" && lineStart {
				act += fmt.Sprintf(ShowID, LastTriceID)
			}
			act += fmt.Sprint(string(buf[:n]))
			lineStart = false
		}
		act = strings.TrimSuffix(act, "\\n")
		act = strings.TrimSuffix(act, "\n")
		assert.Equal(t, x.exp, act)
	}
}

func TestCOBS(t *testing.T) {
	tt := testTable{ // little endian
		{[]byte{2, 1, 1, 1, 3, 208, 7, 1, 5, 192, 1, 196, 188, 1, 1, 1, 1, 0}, `MSG: START select = 0, TriceDepthMax =   0`},
		{[]byte{2, 1, 1, 1, 3, 209, 7, 1, 5, 193, 1, 205, 209, 1, 2, 28, 1, 0}, `MSG: STOP  select = 0, TriceDepthMax =  28`},
	}
	var out bytes.Buffer
	doCOBSTableTest(t, &out, NewCOBSDecoder, LittleEndian, tt)
	assert.Equal(t, "", out.String())
}

// used command to get sequences: "trice l -p COM1 -s -debug"
//        02 01 01 01 03 d0 07 01 05 c0 01 c4 bc 01 01 01 01 00 00 00 02 01 01 01 03 d1 07 01 05 c1 01 cd d1 01 02 1c 01 00 00 00
//  COBS: 02 01 01 01 03 d0 07 01 05 c0 01 c4 bc 01 01 01 01 00
//  -> PKG:  01 00 00 00 d0 07 00 00 c0 01 c4 bc 00 00 00 00
//  TRICE ->    00000001   timestamp c0 01 c4 bc 00 00 00 00
//  COBS:                                                       00
//  COBS:                                                          00
//  COBS:                                                             02 01 01 01 03 d1 07 01 05 c1 01 cd d1 01 02 1c 01 00
//  -> PKG:                                                              01 00 00 00 d1 07 00 00 c1 01 cd d1 00 00 1c 00
//  TRICE ->                                                                00000001   timestamp c1 01 cd d1 00 00 1c 00
//  COBS:                                                                                                                   00
//  COBS:                                                                                                                      00
//  func _TestTranslate(t *testing.T) {
//  	var (
//  		// til is the trace id list content for test
//  		idl = `{
//  			"48324": {
//  				"Type": "TRICE16",
//  				"Strg": "MSG: START select = %d, TriceDepthMax =%4u\\n"
//  			},
//  			"53709": {
//  				"Type": "TRICE16",
//  				"Strg": "MSG: STOP  select = %d, TriceDepthMax =%4u\\n"
//  			}
//  		}
//  	`
//  	)
//  	glob.Lock()
//  	defer glob.Unlock()
//  	sw := emitter.New(os.Stdout)
//  	lu := make(id.TriceIDLookUp) // empty
//  	assert.Nil(t, lu.FromJSON([]byte(idl)))
//  	m := new(sync.RWMutex) // m is a pointer to a read write mutex for lu
//  	Encoding = "COBS"
//  	TargetEndianess = "littleEndian"
//  	receiver.Port = "DUMP"
//  	ShowID = "%d"
//  	defer func() {
//  		ShowID = "" // reset to default
//  	}()
//  	verbose := true
//
//  	buf := new(bytes.Buffer)
//  	rc, err := receiver.NewReadCloser(buf, verbose, receiver.Port, "02 01 01 01 03 d0 07 01 05 c0 01 c4 bc 01 01 01 01 00")
//  	assert.Nil(t, err)
//  	assert.Equal(t, buf.String(), "")
//  	err = Translate(buf, sw, lu, m, rc)
//  	assert.Nil(t, err)
//  	assert.Equal(t, "bla", buf.String())
//  }
//
//  var glob *sync.RWMutex // tests changing global values need to exclude each other
//
//  func init() {
//  	glob = new(sync.RWMutex)
//  }
