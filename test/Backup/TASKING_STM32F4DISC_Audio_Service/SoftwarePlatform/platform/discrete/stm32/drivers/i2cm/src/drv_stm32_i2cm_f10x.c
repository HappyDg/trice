/* ------------------------------------------------------------
**
**  Copyright (c) 2013-2015 Altium Limited
**
**  This software is the proprietary, copyrighted property of
**  Altium Ltd. All Right Reserved.
**
**  SVN revision information:
**  $Rev: 14907 $:
**  $Date: 2015-01-19 13:30:51 +0100 (Mon, 19 Jan 2015) $:
**
** ------------------------------------------------------------
*/

#include <assert.h>

#if defined(STM32F10X)

#include <stdint.h>
#include <drv_i2cm.h>
#include <time.h>
#include <timing.h>
#include <devices.h>
#include "drv_stm32_i2cm_cfg_instance.h"
#include "per_stm32f10x_i2c_cfg_instance.h"
#include "stm32f10x_i2c.h"
#include "../internal/drv_stm32_i2cm_internal.h"

#include <stm32_chip_config.h>



i2cm_t i2cm_drv_table[DRV_STM32_I2CM_INSTANCE_COUNT];

/**
 * @brief Generate a reset sequence on the I2C bus and initialize the pins to I2C
 *
 * I2C reset consists of generation of up to 9 clocks while SDA is kept low (by a slave), than generate a STOP condition
 *
 * @param drv pointer to driver context
 */

static int i2cm_reset( i2cm_t * drv, const per_stm32f10x_i2c_cfg_instance_t * restrict per_cfg )
{
    GPIO_TypeDef *scl_port;
    GPIO_TypeDef *sda_port;
    uint16_t     scl_pin;
    uint16_t     sda_pin;
    GPIO_InitTypeDef gpio_init_struct;
    clock_t t;
    const clock_t timeout = CLOCKS_PER_SEC / 65536; // Actual speed should be 16384 kHz?

    switch( per_cfg->instance_id )
    {
#if defined(PINCFG_I2C1)
    case 0:
        scl_port = PINCFG_I2C1_SCL_PORT;
        scl_pin  = PINCFG_I2C1_SCL_PIN;
        sda_port = PINCFG_I2C1_SDA_PORT;
        sda_pin  = PINCFG_I2C1_SDA_PIN;
        break;
#endif
#if defined(PINCFG_I2C2)
    case 1:
        scl_port = PINCFG_I2C2_SCL_PORT;
        scl_pin  = PINCFG_I2C2_SCL_PIN;
        sda_port = PINCFG_I2C2_SDA_PORT;
        sda_pin  = PINCFG_I2C2_SDA_PIN;
        break;
#endif
    default :
        return -1;    // Error, device does not exist
    }

    GPIO_WriteBit( scl_port, scl_pin, Bit_SET );
    GPIO_WriteBit( sda_port, sda_pin, Bit_SET );

    gpio_init_struct.GPIO_Speed = GPIO_Speed_50MHz;
    gpio_init_struct.GPIO_Mode = GPIO_Mode_Out_OD;

    gpio_init_struct.GPIO_Pin = scl_pin;
    GPIO_Init( scl_port, &gpio_init_struct );
    gpio_init_struct.GPIO_Pin = sda_pin;
    GPIO_Init( sda_port, &gpio_init_struct );

    // Generate 9 stop conditions, without start:
    //
    //      ___ ___     ___     ___     ___     ___     ___     ___     ___     ___     __________
    //  SCL ___|   |___| ' |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|
    //                   '
    //      _________    '___     ___     ___     ___     ___     ___     ___     ___     ________
    //  SDA _________|___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|
    //                   '
    //                   stop

    for ( int i = 0; i < 9; i++ )
    {
        // Drop clock
        GPIO_WriteBit( scl_port, scl_pin, Bit_RESET );
        for ( t = clock() + timeout; clock() < t; ) __nop();

        // Drop data
        GPIO_WriteBit( sda_port, sda_pin, Bit_RESET );
        for ( t = clock() + timeout; clock() < t; ) __nop();

        // Assert clock
        GPIO_WriteBit( scl_port, scl_pin, Bit_SET );
        for ( t = clock() + timeout; clock() < t; ) __nop();
        if ( GPIO_ReadInputDataBit( scl_port, scl_pin ) == RESET ) return -1;   // Clock is kept low by a slave :-(

        GPIO_WriteBit( sda_port, sda_pin, Bit_SET );  // Assert data (hopefully)
        for ( t = clock() + timeout; clock() < t; ) __nop();

    }

    if ( GPIO_ReadInputDataBit( sda_port, sda_pin ) == RESET ) return -2;   // Did not finish, data kept low by slave

    per_cfg->pinconfig();

    // Reset the I2C peripheral - it is not happy with unexpected stop conditions
    I2C_SoftwareResetCmd( drv->i2cx, ENABLE );
    I2C_SoftwareResetCmd( drv->i2cx, DISABLE );

    return 0;
}

/**
 * @brief Open the I2CM device driver and initializes the hardware
 *
 * This function opens the device driver for an I2C peripheral on the STM32 core. You should call
 * this function once per instantiation.
 *
 * @param id Instance identifier as generated by the software platform
 *
 * @return NULL on error, pointer to instance context otherwise
 */

i2cm_t * i2cm_open( unsigned int id )
{
    i2cm_t * drv;
    const drv_stm32_i2cm_cfg_instance_t * restrict drv_cfg;
    const per_stm32f10x_i2c_cfg_instance_t * restrict per_cfg;

    drv_cfg = &drv_stm32_i2cm_instance_table[id];
    per_cfg = &per_stm32f10x_i2c_instance_table[drv_cfg->per_stm32_i2c];
    drv = &i2cm_drv_table[id];

    if ( drv->i2cx == NULL )
    {
        drv->i2c_frequency = drv_cfg->i2c_frequency;

        // Initialize the I2C peripheral
        I2C_StructInit( &drv->init );
        drv->init.I2C_Mode = I2C_Mode_I2C;
        drv->init.I2C_DutyCycle = I2C_DutyCycle_2;
        drv->init.I2C_OwnAddress1 = 0x00;
        drv->init.I2C_Ack = I2C_Ack_Enable;
        drv->init.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
        drv->init.I2C_ClockSpeed = drv_cfg->i2c_frequency;

        // Enable clocking of AFIO_MAPR register
        RCC_APB2PeriphClockCmd( RCC_APB2Periph_AFIO, ENABLE );

        switch( per_cfg->instance_id )
        {
        case 0 :
            RCC_APB1PeriphClockCmd( RCC_APB1Periph_I2C1, ENABLE );
            drv->i2cx = I2C1;
            break;

        case 1 :
            RCC_APB1PeriphClockCmd( RCC_APB1Periph_I2C2, ENABLE );
            drv->i2cx = I2C2;
            break;

        }

        per_cfg->pinconfig();

        if (i2cm_reset( drv, per_cfg )) return NULL;

        I2C_Cmd( drv->i2cx, ENABLE );
        I2C_Init( drv->i2cx, &drv->init );
    }
    return drv;
}


#endif
