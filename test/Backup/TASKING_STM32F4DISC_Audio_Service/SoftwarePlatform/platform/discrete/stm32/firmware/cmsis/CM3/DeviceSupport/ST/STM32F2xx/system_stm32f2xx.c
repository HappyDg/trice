/**
  ******************************************************************************
  * @file    system_stm32f2xx.c
  * @author  MCD Application Team
  * @version V1.1.3
  * @date    05-March-2012
  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
  *          This file contains the system clock configuration for STM32F2xx devices,
  *          and is generated by the clock configuration tool
  *          "STM32f2xx_Clock_Configuration_V1.0.0.xls"
  *
  * 1.  This file provides two functions and one global variable to be called from
  *     user application:
  *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
  *                      and Divider factors, AHB/APBx prescalers and Flash settings),
  *                      depending on the configuration made in the clock xls tool.
  *                      This function is called at startup just after reset and
  *                      before branch to main program. This call is made inside
  *                      the "startup_stm32f2xx.s" file.
  *
  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
  *                                  by the user application to setup the SysTick
  *                                  timer or configure other parameters.
  *
  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
  *                                 be called whenever the core clock is changed
  *                                 during program execution.
  *
  * 2. After each device reset the HSI (16 MHz) is used as system clock source.
  *    Then SystemInit() function is called, in "startup_stm32f2xx.s" file, to
  *    configure the system clock before to branch to main program.
  *
  * 3. If the system clock source selected by user fails to startup, the SystemInit()
  *    function will do nothing and HSI still used as system clock source. User can
  *    add some code to deal with this issue inside the SetSysClock() function.
  *
  * 4. The default value of HSE crystal is set to 25MHz, refer to "HSE_VALUE" define
  *    in "stm32f2xx.h" file. When HSE is used as system clock source, directly or
  *    through PLL, and you are using different crystal you have to adapt the HSE
  *    value to your own configuration.
  *
  * 5. This file configures the system clock as follows:
  *=============================================================================
  *=============================================================================
  *        Supported STM32F2xx device revision    | Rev B and Y
  *-----------------------------------------------------------------------------
  *        VDD(V)                                 | 3.3
  *-----------------------------------------------------------------------------
  *        Prefetch Buffer                        | ON
  *-----------------------------------------------------------------------------
  *        Instruction cache                      | ON
  *-----------------------------------------------------------------------------
  *        Data cache                             | ON
  *-----------------------------------------------------------------------------
  *=============================================================================
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/** @addtogroup CMSIS
  * @{
  */

/** @addtogroup stm32f2xx_system
  * @{
  */

/** @addtogroup STM32F2xx_System_Private_Includes
  * @{
  */

#include "stm32f2xx.h"
#include "stm32f2xx_cmsis_cfg.h"
/**
  * @}
  */

/** @addtogroup STM32F2xx_System_Private_TypesDefinitions
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32F2xx_System_Private_Defines
  * @{
  */

/*!< Uncomment the following line if you need to use external SRAM mounted
     on STM322xG_EVAL board as data memory  */
/* #define DATA_IN_ExtSRAM */

/*!< Uncomment the following line if you need to relocate your vector Table in
     Internal SRAM. */
/* #define VECT_TAB_SRAM */
#define VECT_TAB_OFFSET  0x00 /*!< Vector Table base offset field.
                                   This value must be a multiple of 0x200. */

#if STM32F2XX_CMSIS_CLKSRC == STM32F2XX_CMSIS_CLKSRC_HSI
#endif
#if STM32F2XX_CMSIS_CLKSRC == STM32F2XX_CMSIS_CLKSRC_HSE
#  define SYSCLOCK_SETUP_HSE
#  define SYSCLOCK_CLKSRC  RCC_CFGR_SW_HSE
#endif
#if STM32F2XX_CMSIS_CLKSRC == STM32F2XX_CMSIS_CLKSRC_PLLCLKBYHSI
#  define SYSCLOCK_SETUP_PLL
#  define SYSCLOCK_PLL_INPUT  RCC_PLLCFGR_PLLSRC_HSI
#  define SYSCLOCK_CLKSRC  RCC_CFGR_SW_PLL
#endif
#if STM32F2XX_CMSIS_CLKSRC == STM32F2XX_CMSIS_CLKSRC_PLLCLKBYHSE
#  define SYSCLOCK_SETUP_HSE
#  define SYSCLOCK_SETUP_PLL
#  define SYSCLOCK_PLL_INPUT  RCC_PLLCFGR_PLLSRC_HSE
#  define SYSCLOCK_CLKSRC  RCC_CFGR_SW_PLL
#endif

#define SYSCLOCK_FLASHLATENCY (STM32F2XX_CMSIS_CLOCKHZ / 30000000)

/**
  * @}
  */

/** @addtogroup STM32F2xx_System_Private_Macros
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32F2xx_System_Private_Variables
  * @{
  */

  uint32_t SystemCoreClock = STM32F2XX_CMSIS_CLOCKHZ;

  __I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};

/**
  * @}
  */

/** @addtogroup STM32F2xx_System_Private_FunctionPrototypes
  * @{
  */

static void SetSysClock(void);
#ifdef DATA_IN_ExtSRAM
  static void SystemInit_ExtMemCtl(void);
#endif /* DATA_IN_ExtSRAM */

/**
  * @}
  */

/** @addtogroup STM32F2xx_System_Private_Functions
  * @{
  */

/**
  * @brief  Setup the microcontroller system
  *         Initialize the Embedded Flash Interface, the PLL and update the
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;

#ifdef DATA_IN_ExtSRAM
  SystemInit_ExtMemCtl();
#endif /* DATA_IN_ExtSRAM */

  /* Configure the System clock source, PLL Multiplier and Divider factors,
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
#endif
}

/**
  * @brief  Update SystemCoreClock variable according to Clock Register Values.
  *         The SystemCoreClock variable contains the core clock (HCLK), it can
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  *
  * @note   Each time the core clock (HCLK) changes, this function must be called
  *         to update SystemCoreClock variable value. Otherwise, any configuration
  *         based on this variable will be incorrect.
  *
  * @note   - The system frequency computed by this function is not the real
  *           frequency in the chip. It is calculated based on the predefined
  *           constant and the selected clock source:
  *
  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
  *
  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
  *
  *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**)
  *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
  *
  *         (*) HSI_VALUE is a constant defined in stm32f2xx.h file (default value
  *             16 MHz) but the real value may vary depending on the variations
  *             in voltage and temperature.
  *
  *         (**) HSE_VALUE is a constant defined in stm32f2xx.h file (default value
  *              25 MHz), user has to ensure that HSE_VALUE is same as the real
  *              frequency of the crystal used. Otherwise, this function may
  *              have wrong result.
  *
  *         - The result of this function could be not correct when using fractional
  *           value for HSE crystal.
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;

  switch (tmp)
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
      break;
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;

      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      SystemCoreClock = pllvco/pllp;
      break;
    default:
      SystemCoreClock = HSI_VALUE;
      break;
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
}

/**
  * @brief  Configures the MCO outputs, System clock source, PLL Multiplier and Divider factors,
  *         AHB/APBx prescalers and Flash settings
  * @Note   This function should be called only once the RCC clock configuration
  *         is reset to the default reset state (done in SystemInit() function).
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
#ifdef SYSCLOCK_SETUP_HSE
  __IO uint32_t StartUpCounter = 0;
#endif

  /* Configure MCO clock outputs */
  RCC->CFGR |= (STM32F2XX_CMSIS_MCO1SRC << 21) | (STM32F2XX_CMSIS_MCO1PRE << 24);
  RCC->CFGR |= (STM32F2XX_CMSIS_MCO2SRC << 30) | (STM32F2XX_CMSIS_MCO2PRE << 27);

  /* At this stage the HSI is enabled and used as System clock source */

#ifdef SYSCLOCK_SETUP_HSE
// use pincfg document setting or backup from core plugin
# if defined(PINCFG_RCC_OSC_HSE_EXTERNAL_CLOCK_SOURCE) || (defined(STM32F2XX_CMSIS_HSE_BYPASS) && STM32F2XX_CMSIS_HSE_BYPASS)
  /* Bypass HSE oscillator */
  RCC->CR |= RCC_CR_HSEBYP;
# endif

  /* Enable HSE */
  RCC->CR |= RCC_CR_HSEON;

  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
  } while (((RCC->CR & RCC_CR_HSERDY) == RESET) && (++StartUpCounter != HSE_STARTUP_TIMEOUT));

  if ((RCC->CR & RCC_CR_HSERDY) == RESET)
  {
      /* If HSE fails to start-up, the application will have wrong clock
         configuration. User can add here some code to deal with this error */
  }
  else
#endif
  {
    /* HCLK */
    RCC->CFGR |= (STM32F2XX_CMSIS_AHB << 4);

    /* PCLK2 */
    RCC->CFGR |= (STM32F2XX_CMSIS_APB2 << 13);

    /* PCLK1 */
    RCC->CFGR |= (STM32F2XX_CMSIS_APB1 << 10);

#ifdef SYSCLOCK_SETUP_PLL
    /* Configure the main PLL */
    RCC->PLLCFGR = STM32F2XX_CMSIS_PLL_M | (STM32F2XX_CMSIS_PLL_N << 6) | (STM32F2XX_CMSIS_PLL_P << 16) |
                   (SYSCLOCK_PLL_INPUT) | (STM32F2XX_CMSIS_PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
    {
    }
#endif

    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    do
    {
      FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN | SYSCLOCK_FLASHLATENCY;
      /* Check that the new number of wait states is taken into account to access */
      /* the Flash memory by reading the FLASH_ACR register */
    }
    while ((FLASH->ACR & FLASH_ACR_LATENCY) != SYSCLOCK_FLASHLATENCY);

#ifdef SYSCLOCK_CLKSRC
    /* Select the given clock as system clock source */
    RCC->CFGR |= SYSCLOCK_CLKSRC;

    /* Wait till the given clock is used as system clock source */
    while ((RCC->CFGR & RCC_CFGR_SWS ) != (SYSCLOCK_CLKSRC << 2));
    {
    }
#endif
  }
}


#ifdef DATA_IN_ExtSRAM
/* MM: To be able to locate all sources and stack also in external memory,
 * we initialize those memories using an init_memory call as early as possible
 * in the stratup sequence. We observed many different configurations for the
 * FSMC. Below you will find the configuration we use in our init_memory function.
 *
 * Initialize the memory controller on the STM322xG-EVAL board to drive
 * - EXT_SRAM 0x64000000 - 0x641FFFFF (2048kB IS61WV102416BLL (1024k x 16bit)
 *   in memory bank 1 region 2
 * To be able to use the external memory we need to
 * configure the FSMC GPIO pins and the FSMC registers. The process of
 * determining the right values for DATAST and the ADDSET timing values in the
 * FSMC BTR registers is not trivial. The most important thing is not to drive
 * the memory to fast (beyond its maximum read/write cycle time). tWC will
 * probably be bigger or equal to tRC so this means
 * (ADDSET + (DATAST+1))*tHCLK >= tWC.
  */
void SystemInit_ExtMemCtl(void)
{
/*-- GPIOs Configuration -----------------------------------------------------*/
/*
 +-------------------+--------------------+------------------+------------------+
 +                       SRAM pins assignment                                  +
 +-------------------+--------------------+------------------+------------------+
 | PD0  <-> FSMC_D2  | PE0  <-> FSMC_NBL0 | PF0  <-> FSMC_A0 | PG0 <-> FSMC_A10 |
 | PD1  <-> FSMC_D3  | PE1  <-> FSMC_NBL1 | PF1  <-> FSMC_A1 | PG1 <-> FSMC_A11 |
 | PD4  <-> FSMC_NOE | PE3  <-> FSMC_A19  | PF2  <-> FSMC_A2 | PG2 <-> FSMC_A12 |
 | PD5  <-> FSMC_NWE | PE7  <-> FSMC_D4   | PF3  <-> FSMC_A3 | PG3 <-> FSMC_A13 |
 | PD8  <-> FSMC_D13 | PE8  <-> FSMC_D5   | PF4  <-> FSMC_A4 | PG4 <-> FSMC_A14 |
 | PD9  <-> FSMC_D14 | PE9  <-> FSMC_D6   | PF5  <-> FSMC_A5 | PG5 <-> FSMC_A15 |
 | PD10 <-> FSMC_D15 | PE10 <-> FSMC_D7   | PF12 <-> FSMC_A6 | PG9 <-> FSMC_NE2 |
 | PD11 <-> FSMC_A16 | PE11 <-> FSMC_D8   | PF13 <-> FSMC_A7 |------------------+
 | PD12 <-> FSMC_A17 | PE12 <-> FSMC_D9   | PF14 <-> FSMC_A8 |
 | PD13 <-> FSMC_A18 | PE13 <-> FSMC_D10  | PF15 <-> FSMC_A9 |
 | PD14 <-> FSMC_D0  | PE14 <-> FSMC_D11  |-----------------+
 | PD15 <-> FSMC_D1  | PE15 <-> FSMC_D12  |
 +-------------------+--------------------+
*/
   /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */
  RCC->AHB1ENR   = 0x00000078;
  /* Connect PDx pins to FSMC Alternate function */
  GPIOD->AFR[0]  = 0x00cc00cc;
  GPIOD->AFR[1]  = 0xcccccccc;
  /* Configure PDx pins in Alternate function mode */
  GPIOD->MODER   = 0xaaaa0a0a;
  /* Configure PDx pins speed to 100 MHz */
  GPIOD->OSPEEDR = 0xffff0f0f;
  /* Configure PDx pins Output type to push-pull */
  GPIOD->OTYPER  = 0x00000000;
  /* No pull-up, pull-down for PDx pins */
  GPIOD->PUPDR   = 0x00000000;

  /* Connect PEx pins to FSMC Alternate function */
  GPIOE->AFR[0]  = 0xc000c0cc;
  GPIOE->AFR[1]  = 0xcccccccc;
  /* Configure PEx pins in Alternate function mode */
  GPIOE->MODER   = 0xaaaa808a;
  /* Configure PEx pins speed to 100 MHz */
  GPIOE->OSPEEDR = 0xffffc0cf;
  /* Configure PEx pins Output type to push-pull */
  GPIOE->OTYPER  = 0x00000000;
  /* No pull-up, pull-down for PEx pins */
  GPIOE->PUPDR   = 0x00000000;

  /* Connect PFx pins to FSMC Alternate function */
  GPIOF->AFR[0]  = 0x00cccccc;
  GPIOF->AFR[1]  = 0xcccc0000;
  /* Configure PFx pins in Alternate function mode */
  GPIOF->MODER   = 0xaa000aaa;
  /* Configure PFx pins speed to 100 MHz */
  GPIOF->OSPEEDR = 0xff000fff;
  /* Configure PFx pins Output type to push-pull */
  GPIOF->OTYPER  = 0x00000000;
  /* No pull-up, pull-down for PFx pins */
  GPIOF->PUPDR   = 0x00000000;

  /* Connect PGx pins to FSMC Alternate function */
  GPIOG->AFR[0]  = 0x00cccccc;
  GPIOG->AFR[1]  = 0x000000c0;
  /* Configure PGx pins in Alternate function mode */
  GPIOG->MODER   = 0x00080aaa;
  /* Configure PGx pins speed to 100 MHz */
  GPIOG->OSPEEDR = 0x000c0fff;
  /* Configure PGx pins Output type to push-pull */
  GPIOG->OTYPER  = 0x00000000;
  /* No pull-up, pull-down for PGx pins */
  GPIOG->PUPDR   = 0x00000000;

/*-- FSMC Configuration ------------------------------------------------------*/
  /* Enable the FSMC interface clock */
  RCC->AHB3ENR         = 0x00000001;
  /* Enable memory bank 1 region (chip select / not enable) 2 for use as SRAM
   * in standard mode 1 (EXTMOD bit is 0), databus width 16 and write enabled.
*/
  FSMC_Bank1->BTCR[2]  = 0x00001011;
  /* Data phase duration 5 HCLK, Adress setup phase duration is 2 HCLK */
  FSMC_Bank1->BTCR[3]  = 0x00000502;
  /* disable region (chip select / not enable) 1, 3 and 4 */
  FSMC_Bank1->BTCR[0]  = 0x0;
  FSMC_Bank1->BTCR[4]  = 0x0;
  FSMC_Bank1->BTCR[6]  = 0x0;
}
#endif /* DATA_IN_ExtSRAM */


/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
